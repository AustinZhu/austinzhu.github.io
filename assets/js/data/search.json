[ { "title": "遵从你的内心", "url": "/posts/Follow-Your-Heart/", "categories": "Blogs", "tags": "life", "date": "2022-03-22 03:28:02 +0900", "snippet": " Your time is limited, so don’t waste it living someone else’s life.Don’t be trapped by dogma — which is living with the results of other people’s thinking.Don’t let the noise of others’ opinions drown out your own inner voice.And most important, have the courage to follow your heart and intuition.They somehow already know what you truly want to become.Everything else is secondary. —— Steve Jobs 人生有限，所以不要把时间浪费在重复其他人的生活上。不要被教条束缚，那只是根据别人的思维结果而生活，不要让他人的喧嚣纷繁，淹没了自己内心的声音。最重要的是，你要有勇气去跟随你的直觉和心灵，因为它们在某种程度上已经知道你想要成为什么样子，所有其他的事情都是次要的。 —— 乔布斯写在前面又是一年毕业季，最近和几位朋友聊起学习工作等话题，字里行间透露着他们的迷茫和疲倦。究其原因，无非是就职不顺，工作枯燥，找不到目标等等。另一些朋友则找到了他们理想的工作，继续挑战自我。我不禁思考，为什么有的人可以活的非常快乐，热爱他们的工作和研究，有的人只能随波逐流，疲于奔命。我想把这些思考的结果文字化，以便于后日反思，警醒自己，于是便有了这篇博客。如果你觉得这是励志鸡汤，并且喝了下去还觉得很有感触，甚至试图效仿，说明你没有真正理解我想表达的意思。关于学习我从来都不是一个让老师放心的好学生。我顶撞老师，被体罚过，被叫过家长，打过架。我与大部分家长推崇的教育路线可以说是格格不入。从小学到高中，我没有参加过任何的补习班。别的同学的周末都在各种培训机构度过，而我就在家里看书或是在电脑面前捣鼓各种软件和沙盒游戏。考试前，别的同学都在各种刷题，我却在书桌下设计我梦想中的机场。自然，我的成绩是比不过一些尖子生，但是我的成绩一直保持在中上，超过了很多去上补习班的同学。街坊邻居看来，我学的这么轻松，时不时还能拿到个班级前几的好成绩，便会夸奖一番。其实我并不聪明，我也不努力，我只是喜欢收集知识的碎片而已。班主任时常告诉我的父母，如果我可以更加用功点，把心思放在学习上，成绩会更好。这简直是大错特错！很多同学在补习班并没有学到真正的知识和学习方法，只不过是为了敷衍家长和老师罢了。我看着他们的兴趣爱好，被无尽的题海和老师家长的期待所吞噬，撕裂，在一次次与老师和家长的抗争中，失去了对学习的热情。我敬佩成绩优异的同学为此付出的努力和汗水，但我知道，这不是我想要的。我想要的是在现实世界与知识的互动，而不仅仅是写在考卷上的一个标准的答案。我想要的是好奇心满足之后，那种内心的愉悦。到了大学，我几乎没有认真听过大学课上的内容，但是我的GPA还是在3以上。很多教授并不懂得怎么教书，所以一些真正对我有帮助的内容，反而是我在图书馆自学的。到了大二，我逐渐觉得我并不是做研究的料，于是我开始寻找专业相关的实习，在实习中运用课上学到的一些内容。渐渐的我知道了我喜欢的不是计算机学科，而是其中的一小部分。因此我不会为了分数花时间在我不感兴趣的课上。我记得那时父母老师都会说：你是为了自己而学习。然而现实是，你学习的内容是被教育大纲所指定的，所以实际上你还不是为了自己而学习。学习，只是了解世界运行的方法而已，如果你失去了对这个世界最本真的好奇心，那么你就永远寻求不到真知。关于工作很多同学都想要卷进大厂，觉得进入大厂有良好的平台，丰厚的待遇。如果进不去大厂，就辜负了父母的期待，前途一片灰暗。这种价值观导致我的一些朋友在找工作期间都快抑郁了。然后恶性循环，觉得自己什么都不行，然后更找不到工作了，就开始摆烂。我现在准备入职的公司，并不是大厂，但公司允许副业，平时加班也不是很频繁。还有一个重要的原因是里面的同事非常有趣，我在实习中认识了骑车横跨美洲大陆的S桑，认识了去东欧留学创办公司的Y桑，还认识了一群热爱技术的同学。这难道不比量产型的中国小镇做题家和卷王有意思的多吗？我喜欢我的工作，因为开发让我快乐，就算加班我也乐此不疲。我在工作中可以发现新的架构设计，优美的代码，有趣的项目，顺便还能拿到报酬。当我和别人说起时，他们总会觉得我是幸运的，可以把爱好做成工作。其实，每个人都可以在工作中获得快乐。我不会为了金钱，光环而选择一个行业，一份工作。我更在乎这份工作能不能让我实现自己的价值，我能不能做一些有趣的事情。如果在工作中可以，那当然是最好的。如果这份工作本身不能做到这一点，那么最好有业余时间可以让我实现自己的价值。最差的一类工作就是，在你人生最有活力的十来年，压榨你的时间，让你身心俱疲，间接压缩你的成长空间，最后当你失去了价值之后，将你扫地出门。这是非常悲哀的，特别是对于一些长时间干着没有价值的工作的，或是摸鱼躺平不去提升自己的人来说。很可能在找下一份工作的时候会出现薪资要求和能力不匹配的问题。现在很多人觉得互联网，IT高薪就想入行，市面上各种培训班层出不穷。扪心自问，你真的喜欢编程，研究技术吗？你愿意在工作之余学习新的行业知识吗？如果你不喜欢它，那在职业道路上又能走多远呢？永远做你热爱的事情，把它当成你的事业，哪怕它现在不能为你带来富裕，至少你获得了快乐。很多年长的人会对此嗤之以鼻，认为名利才是这个世界的硬通货，快乐又不能当饭吃。殊不知当你快乐的时候，你的心态是健康的，你就会发现更多的机会，创造更有价值的东西。届时，你还担心没有金钱吗？关于选择很多人的专业，都是父母和老师选择的。有些父母觉得自己的老本行不错，就让自己的孩子学了土木。有些父母听别人说金融赚钱，于是让孩子报了经济。而这些同学从来没有调查过这个专业要学些什么，他们毫无准备的进入大学，普普通通的度过四年，然后面临就业的危机。为了逃避危机，有些同学不得不加入了考研大军。不要对你的父母和师长言听计从，除非他们是这个领域的主宰者和领军人物。千万不要把选择权交给别人。如果结果不尽人意，你会逃避责任，然而责怪别人也无济于事，因为承担后果的是你自己。如果结果十分满意，你会依赖别人，而不会去思考为什么要这么选择。我选择计算机专业，是一件自然而然的事情，就像点连成线那样简单。小学的时候，因为父母办公的需要，家里有了第一台电脑。在耳濡目染中，我学会了拨号上网，Windows的各种操作，如何使用Excel表格等。我甚至还把电脑主机拆开，差点没能重新组装起来，为此还挨了一顿骂。中学的时候，我开始看电脑论坛，学着P图，剪视频，搭建网站，配置Wi-Fi等等小技巧。我第一次接触编程，是在高中，当时我为了制作一个游戏的插件，需要处理地图数据，于是就学了点基础的Python。也是这个机会，让我接触到了开放地图数据这个领域，之后还去了日本，意大利，德国参加会议交流。并且，为了理解程序运行的原理，我去图书馆借阅了《计算机导论》，由此对计算机学科有了一个初步的认知。那时我想，以后大学就学计算机专业吧。在高二的时候，我决定出国，因为我厌恶国内的教育体系，我不想再玩分数游戏了。当时身边的同学都去美国，于是我也准备申请美国的大学。然而在申请过程中，我发现我对美国的文化和生活完全没有认知。而日剧和动漫让我感到，这就是我想要去的地方。恰好凭借着对日剧和动漫的热情，我学会了日语，顺利通过了N1。于是我申请了早稻田大学，并且在最后放弃了美国的Offer，来到了日本。看到这里，一定有人觉得，不去美国去日本，怕不是脑子坏了。那么不好意思，你可能不是这篇文章的受众。我清楚的知道，如果我因为从众去了美国，就违背了我自己的意志 —— It will never end up well。写在最后我很感激我的父母，他们总是支持我的决定。在我童年就告诉我如何识人识势，如何做出符合环境的选择。当我做出了错误的选择时，他们也不会帮我处理，而是让我自己承担后果和反思。对于不那么幸运的人来说，父母师长朋友对你人生的干预，也许是你成长路上最大的障碍。他们很可能会让你偏离你内心的追求，一点点地失去对人生的自主权。你可以参考他们的建议，但千万不能让他们指导和干预你的选择，尽管他们可能是处于好意。不要因为他人的建议而贸然做出选择，这样不会让你活成别人的样子，更不会活成你自己的样子。如果是你深思熟虑的决定，不要因为他人的反对而犹豫，这样只会错过机会。如果有想做的事情，就勇敢的做吧，不要在乎别人的眼光。其实上帝给每个人都安排了一条很好的路，只要你从一开始就遵从你内心的想法，屏蔽各种杂音。这条路大概不会让你走向大富大贵，当上CEO迎娶白富美，但是绝不会让你每日消沉，惶惶不安。悲哀的是，很多人总是羡慕别人的生活，为自己的现状焦虑烦恼。很多人宁愿相信别人，也不愿相信自己，在挫折后陷入无奈和怀疑。那年，当我躺在在东京圣路加医院的病床上，亲自签下病危通知书的那个晚上，我真正懂得了，“人生是美好的，又是短暂的”这句话，不是存在于遥不可及的励志句子和毒鸡汤中，而是随时有可能出现在现实中的。在这个魔幻的时代，你永远不知道明天会发生什么，那为什么不活出自己的精彩呢？永远遵从你的内心，这样你会生活的很快乐。" }, { "title": "Morphisms and Objects", "url": "/posts/Morphisms-And-Objects/", "categories": "Notes", "tags": "category theory, type theory", "date": "2021-09-28 10:08:21 +0900", "snippet": "" }, { "title": "Category Basics", "url": "/posts/Category-Basics/", "categories": "Notes", "tags": "category theory, type theory", "date": "2021-08-25 17:21:04 +0900", "snippet": "It seems inevitable that, after one learned Haskell, there’s a good possibility she will become a victim of category theory. This is a series(hopefully) of notes about category theory.Category Theory is the theory using formal method to study the semantics of cats a language that is spoken by mathematicians, just like Design Pattern is a language spoken by senior software engineers. Of course, the latter one reads less exotic and sometimes harmful.Definition of CategoryA category \\(C\\) consists of: A collection of objects, \\(\\text{Ob}(C)\\); A collection of morphisms(arrows), \\(\\text{Mor}(C)\\); For each morphism(arrow) \\(f\\), a domain object \\(A\\) and a codomain object \\(B\\). \\(f:A\\rightarrow B\\) and \\(dom(f)=A, cod(f)=B\\). The collection of morphisms(arrows) between two objects: domain \\(A\\) and codomain \\(B\\), is denoted as \\(\\text{Hom}(A, B)\\). A binary operator $\\circ$ called composition, satisfying: For any pair of arrows \\(f:A\\rightarrow B\\) and \\(g:B\\rightarrow C\\), an arrow \\(g\\circ f:A\\rightarrow C\\). (Associativity) For any \\(f:A\\rightarrow B, g: B\\rightarrow C, h:C\\rightarrow D\\), we have \\(h\\circ(g\\circ f)=(h\\circ g)\\circ f\\). (Identity) For each object \\(A\\), an identity arrow \\(id_A\\), such that for any arrow \\(f\\), \\(id_{A}\\circ f=f=f\\circ id_{A}\\). Examples of Category \\[\\textbf{Set}\\] Objects: sets, \\(A\\). Arrows: total functions, \\(f:A\\rightarrow B\\). Composition: function composition. \\[\\textbf{Poset}\\] Objects: partially-ordered sets, \\((P,\\leq)\\). \\(P\\) is a set. \\(\\leq\\) is a reflexive, transitive, antisymmetric relation on $P$. Arrows: total order-preserving functions, \\(f:P\\rightarrow Q\\), such that \\(\\forall p,p&#39;\\in P.p\\leq_{P}p&#39; \\rightarrow f(p)\\leq_{Q} f(p&#39;)\\). Composition: function composition. \\[\\textbf{Mon}\\] Objects: monoids, \\((M,\\cdot)\\). \\(M\\) is a set. \\(\\cdot\\) is an associative binary operator on \\(M\\). an identity element \\(e\\in M\\) such that \\(\\forall m\\in M.e\\cdot m=m=m\\cdot e\\). Arrows: monoid homomorphisms, \\(f:M\\rightarrow N\\), such that \\(\\forall m,m&#39;\\in M.m\\cdot_{M}m&#39;=f(m)\\cdot_{N}f(m&#39;)\\) and \\(f(e_{M})=e_{N}\\). Composition: homomorphism composition. \\[\\textbf{Grp}\\] Objects: group, \\((G,\\cdot)\\) \\(G\\) is a set. \\(\\cdot\\) is an associative binary operator. an identity element \\(e\\in G\\) such that \\(\\forall g\\in G.g\\cdot e=g=e\\cdot g\\). inverse: \\(\\forall g\\in G.\\exists g^{-1}\\in G.g\\cdot g^{-1}=e=g^{-1}\\cdot g\\). Arrows: group homomorphisms, \\(f:G\\rightarrow H\\), such that \\(\\forall g,g&#39;\\in G.g\\cdot_G g&#39;=f(g)\\cdot_H f(g&#39;)\\), \\(f(e_M)=e_N\\) Composition: homomorphism composition. \\[\\textbf{Ω-Alg}\\] Objects: Ω-Algebras, \\((\\vert A\\vert, a)\\). \\(\\vert A\\vert\\) is a set called carrier. \\(a:\\sum_{\\omega\\in\\Omega}\\vert A\\vert^{ar(\\omega)}\\rightarrow\\vert A\\vert\\) is an interpretation. \\(\\Omega\\) is a set of operator (signature). \\(ar(\\omega)\\) is the arity of \\(\\omega\\). Arrows: \\(\\Omega\\)-homomorphisms, \\(h:\\vert A\\vert\\rightarrow\\vert B\\vert\\), such that \\(\\forall\\omega\\in\\Omega.h\\left(a(x_1,...,x_{ar(\\omega)})\\right)=b\\left(h(x_1),...,h(x_{ar(\\omega)})\\right)\\). Composition: homomorphism composition. More examples: Categorical Logic Objects: formulas, \\(A\\). Arrows: proofs, \\(f:A\\rightarrow B\\). Composition: transitivity of implication.\\(\\begin{prooftree}\\AxiomC{$f:A\\rightarrow B$}\\AxiomC{$g:B\\rightarrow C$}\\BinaryInfC{$g\\circ f:A\\rightarrow C$}\\end{prooftree}\\) Functional Programming Language Objects: types, \\(T\\). Arrows: functions, \\(f: T\\rightarrow U\\) Composition: function composition Dual Category \\(\\textbf{C}^{\\textbf{op}}\\) of \\(\\textbf{C}\\) Objects: \\(\\text{Ob}(\\textbf{C})\\) Arrows: opposite of arrows in \\(\\textbf{C}\\). \\(\\forall f:A\\rightarrow B\\) from \\(\\textbf{C}\\), we have \\(f^{op}:B\\rightarrow A\\) in \\(\\textbf{C}^{\\textbf{op}}\\) Composition: trivial. Product category \\(\\textbf{C}\\times\\textbf{D}\\) Objects: objects pairs \\((A, B)\\) where \\(A\\) is a \\(\\textbf{C}\\)-object and \\(B\\) is a \\(\\textbf{D}\\)-object. Arrows: arrows pairs \\((f,g)\\) where \\(f\\) is a \\(\\textbf{C}\\)-arrow and \\(g\\) is an \\(\\textbf{D}\\)-arrow. Composition: pairwise composition, \\((f,g)\\circ(h,i)=(f\\circ h,g\\circ i)\\). Subcategory \\(\\textbf{B}\\) of \\(\\textbf{C}\\) Objects: each \\(\\textbf{B}\\)-object in is a \\(\\textbf{C}\\)-object Arrows: for all \\(\\textbf{B}\\)-objects \\(B\\) and \\(B&#39;\\), \\(\\text{Hom}_B(B,B&#39;)\\subseteq \\text{Hom}_C(B,B&#39;)\\) Composition: same as \\(\\textbf{C}\\) Commutative DiagramsDefinitionA diagram in a category \\(\\textbf{C}\\) is a collection of vertices and directed edges, consistently labeled with objects and arrows of \\(\\textbf{C}\\).A diagram is said to commute if for every pair of objects \\(X,Y\\), all the paths from \\(X\\) to \\(Y\\) are equal.ExampleThis diagram commutes: In the inner left squre: \\(m\\circ g=G\\circ l\\) In the inner right squre: \\(r\\circ h=H\\circ m\\) In the outer rectangle: \\(r\\circ h\\circ g=H\\circ G\\circ l\\)" }, { "title": "A Simple REPL For the IMP Language", "url": "/posts/A-Simple-REPL-For-the-IMP-Language/", "categories": "Blogs", "tags": "programming language, haskell", "date": "2020-10-24 20:00:34 +0900", "snippet": "IMP is a simple imperative language described in the book The Formal Semantics of Programming Languages. The schema of the language is defined as follows:\\[\\begin{align*}a:=&amp;amp;n\\mid X\\mid a_0+a_1\\mid a_0-a_1\\mid a_0\\times a_1 &amp;amp; (\\text{Aexp})\\\\b:=&amp;amp;\\textbf{true}\\mid\\textbf{false}\\mid a_0=a_1\\mid a_0\\leq a_1\\mid \\neg b\\mid b_0 \\wedge b_1\\mid b_0 \\vee b_1&amp;amp; (\\text{Bexp})\\\\c:=&amp;amp;\\textbf{skip}\\mid X:= a\\mid c_0;c_1\\mid \\textbf{if }b\\textbf{ then } c_0 \\textbf{ else } c_1\\mid \\textbf{while }b\\textbf{ do }c&amp;amp; (\\text{Com})\\end{align*}\\]The REPL is implemented in Haskell. To play with it, execute stack build --exec IMP-Parser-exe in your favorite terminal and start coding in IMP. Notice there appears to be some bugs when evaluating on some expressions. Please feel free to submit any issue on Github and I will try to fix it in future commits.Here is the link to my project: IMP-Parser" }, { "title": "Church Numeral与Haskell中init函数的联系", "url": "/posts/Church-Numeral-And-Init-in-Haskell/", "categories": "Blogs", "tags": "haskell, lambda calculus", "date": "2020-09-07 10:40:00 +0900", "snippet": "在学习 Haskell 的过程中，碰到了这样的一道习题：使用fold函数编写一个init函数。通过搜索发现了一个非常优雅的解法：init&#39; [] = error &quot;empty list&quot;init&#39; xs = foldr f (const []) xs id where f x g h = h $ g (x:)仔细一看，这和 Church Numeral 里的pred可以说非常相似了!Church NumeralChurch Numeral 使用高阶函数来表示自然数。定义如下,\\[\\forall f\\space R_f\\subseteq D_f\\forall x\\in D_f:n\\space f \\space x=f^nx\\]我们可以在此基础上定义一系列运算：\\[\\begin{align}\\text{succ}&amp;amp;:=\\lambda n.\\lambda f.\\lambda x.f(n\\space f \\space x) \\\\\\text{plus}&amp;amp;:=\\lambda m.\\lambda n.\\lambda f.\\lambda x.m\\space\\text{succ}\\space n=\\lambda m.\\lambda n.\\lambda f.\\lambda x.m\\space f\\space (n\\space f\\space x) \\\\\\text{mult}&amp;amp;:=\\lambda m.\\lambda n.\\lambda f.\\lambda x.m\\space\\text{plus}\\space n=\\lambda m.\\lambda n.\\lambda f.\\lambda x.m\\space (n\\space f)\\space x \\\\\\text{exp}&amp;amp;:=\\lambda m.\\lambda n.\\lambda f.\\lambda x.m\\space\\text{mult}\\space n=\\lambda m.\\lambda n.\\lambda f.\\lambda x.(m\\space n)\\space f\\space x\\end{align}\\]可以看到以上的运算都是由\\(\\text{succ}\\)（后继函数）衍生出来的，那么如果我们想知道一个数的前趋（predecessor）怎么办呢？根据定义，应用函数\\(n\\)次表示\\(n\\)，如果我们想知道\\(n-1\\)，只需要少应用一次函数。于是我们可以试想有一个起始函数\\(g\\)，当对它应用函数\\(f\\)时，它总是返回一个常量\\(x\\)。这样当我们对它应用\\(n\\)次\\(f\\)时，总是会少应用一次。但是这样起始常量就不是\\(x\\)了，而是一个函数，所以在之后的 function application 过程中，产生的数也会被 wrap 在函数中（可以理解为把前一次应用\\(f\\)后的结果放在了一个函数里）。在最后我们需要把包在函数中的 Church Numeral 给取出来。因此我们需要一些辅助函数:\\[\\begin{align}\\text{inc}&amp;amp;:=\\lambda g.\\lambda h.h\\space(g\\space f) \\\\\\text{id}&amp;amp;:=\\lambda u.u \\\\\\text{extract}&amp;amp;:=k\\space\\lambda u.u \\\\\\text{const}&amp;amp;:=\\lambda u.x\\end{align}\\]\\(\\text{inc}\\)用于对包装中的值应用函数，因此\\(\\text{inc}\\space (\\text{value}\\space v)=\\text{value}\\space (f\\space v)\\)且\\(\\text{inc}\\space g=\\text{value}\\space (g\\space f)\\)。\\(\\text{extract}\\)可以将包装中的值取出来，因为\\(\\text{extract}\\space(\\text{value}\\space v)=v\\)而\\(\\text{value}\\space v\\space I=v\\)，相当于对当前的 wrapper 应用了一次\\(\\text{id}\\)函数。最后\\(\\text{const}\\)函数用来返回常量，也就是我们的起始函数，它可以实现\\(\\text{inc const}=\\text{value}\\space x\\)。代入后\\(\\text{pred}\\)函数就等于\\[\\text{pred}:=\\lambda n.\\lambda f.\\lambda x.\\text{extract}\\space(n\\space\\text{inc const})=\\lambda n.\\lambda f.\\lambda x.n\\space (\\lambda g.\\lambda h.h\\space(g\\space f))\\space (\\lambda u.x)\\space (\\lambda u.u)\\]与init的联系我们再看一下pred函数：init&#39; xs = foldr f (const []) xs id where f x g h = h $ g (x:)此处(:)相当于 Church Numeral 定义中的\\(f\\)，整体思路就是如何应用\\(n-1\\)次(:)，从而构建出一个不包含原列表末尾元素的列表（取列表前\\(n-1\\)个元素）。我们先来整理一下这里面的各种函数的类型。foldr :: (a -&amp;gt; b -&amp;gt; b) -&amp;gt; b -&amp;gt; [a] -&amp;gt; bconst [] :: b -&amp;gt; aid :: a -&amp;gt; af :: a -&amp;gt; (([a] -&amp;gt; [a]) -&amp;gt; [a]) -&amp;gt; ([a] -&amp;gt; [a]) -&amp;gt; [a]简单来说，这里的h就是前面的\\(\\text{value}\\)，g :: ([a] -&amp;gt; [a]) -&amp;gt; [a]是\\(\\text{inc}\\)，在fold过程中会不断被应用。const []是起始函数（可以理解为-1），它接受一个任意类型的参数，返回一个空列表。最后fold结束后，id把我们所需要的列表从h中取出来。看一个例子：init&#39; [1,2,3] = foldr f (const []) [1,2,3] id = f 1 (foldr f (const []) [2,3]) id = f 1 (f 2 (foldr f (const []) [3])) id = f 1 (f 2 (f 3 (foldr f (const []) []))) id = id $ f 2 (f 3 (foldr f (const []) [])) (1:) = id $ (1:) $ f 3 (foldr f (const []) []) (2:) = id $ (1:) $ (2:) $ foldr f (const []) [] (3:) = id $ (1:) $ (2:) $ const [] (3:) = id $ (1:) $ (2:) [] = id $ (1:) [2] = id $ [1,2] = [1,2]当然，也有其他的实现方法，在 ghc 中，init是通过增加一个中间参数来实现的（类比 pair 或 tuple）。这个参数保存了上一次递归产生的 list。相比本文中使用的实现更为直观。（全用最基本的 lambda expression 搭积木真是要命:-(" }, { "title": "[LeetCode] 515. Find Largest Value in Each Tree Row", "url": "/posts/LeetCode-515.-Find-Largest-Value-in-Each-Tree-Row/", "categories": "Blogs", "tags": "leetcode", "date": "2020-09-01 11:30:00 +0900", "snippet": " Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed). Example 1: Input: root = [1,3,2,5,3,null,9]Output: [1,3,9] Example 2: Input: root = [1,2,3]Output: [1,3] Example 3: Input: root = [1]Output: [1] Example 4: Input: root = [1,null,2]Output: [1,2] Example 5: Input: root = []Output: [] Constraints: The number of the nodes in the tree will be in the range [1, 104]. -231 &amp;lt;= Node.val &amp;lt;= 231 - 1 Solutiondata Tree = Node Int Tree Tree | Nil deriving (Show, Read, Eq)instance Ord Tree where compare Nil Nil = EQ compare Nil (Node _ _ _) = LT compare (Node _ _ _) Nil = GT compare (Node a _ _) (Node b _ _) = compare a blargestValues :: Tree -&amp;gt; [Tree]largestValues root = largestValues&#39; [root] []largestValues&#39; :: [Tree] -&amp;gt; [Tree] -&amp;gt; [Tree]largestValues&#39; [] maxes = maxeslargestValues&#39; [Nil] _ = []largestValues&#39; nodes maxes = largestValues&#39; (add nodes) ((maximum nodes):maxes) where add :: [Tree] -&amp;gt; [Tree] add [Nil] = [] add [(Node val l r)] | l == Nil &amp;amp;&amp;amp; r == Nil = [] | l == Nil = [r] | r == Nil = [l] | otherwise = [l, r] add ns = foldr (\\x acc -&amp;gt; add [x] ++ acc) [] nsBFS Solution" }, { "title": "[LeetCode] 226. Invert Binary Tree", "url": "/posts/LeetCode-226.-Invert-Binary-Tree/", "categories": "Blogs", "tags": "leetcode", "date": "2020-08-19 10:53:00 +0900", "snippet": " Invert a binary tree. Example: Input: 4 / \\ 2 7/ \\ / \\1 3 6 9 Output: 4 / \\ 7 2/ \\ / \\9 6 3 1 Trivia:This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off. Solutiondata Tree a = Node a (Tree a) (Tree a) | EmptyNodeinvert :: Tree a -&amp;gt; Tree ainvert EmptyNode = EmptyNodeinvert (Node val left right) = Node val (invert right) (invert left)3 simple steps to solve this: Get an opportunity to be interviewed onsite at Google (99% completed) Swap the left subtree and right subtree (99.5% completed) Call invert on their subtrees (100% completed)Excellent! Now you are qualified for an engineer position at Google! (XDDon’t worry if you stuck on step 2 and 3, you can still get hired by Apple!" }, { "title": "Difference Among WHNF, HNF and NF", "url": "/posts/WHNF-And-HNF-in-Haskell/", "categories": "Blogs", "tags": "programming language, haskell", "date": "2020-08-04 12:11:00 +0900", "snippet": "Recently when I was reading the documentation of foldl&#39; in the List module, I had some difficulty understanding the term Weak Head Normal Form.Here is the description of foldl&#39;, a strict version of the lazy foldl: foldl&#39; :: Foldable t =&amp;gt; (b -&amp;gt; a -&amp;gt; b) -&amp;gt; b -&amp;gt; t a -&amp;gt; b Left-associative fold of a structure but with strict application of the operator. This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. length). For a general Foldable structure this should be semantically identical to, foldl&#39; f z = foldl&#39; f z . toList From the description we know that during folding, foldl&#39; will apply the function eagerly to reduce thunks. What is a thunk exactly? A thunk is a value that is not fully evaluated. For example, 1+2.How is that useful? Well, Haskell is a lazy language, and laziness is handy when working on things like infinite sequences. The evaluation strategy of Haskell is called call-by-need. So terms will not be evaluated until it is necessary to do so. Also, once a term is evaluated, its result will be recorded for future usage, which is efficient and desirable (if you live in the world of pure functions).However, in some cases you do want strict evaluation, which might help you avoid StackOverflow errors. During the evaluation, different normal forms come into play.Weak Head Normal Form(WHNF)An expression is in its weak head normal form if one of the following condition holds： The outmost part(i.e. the root node of the AST ) is a data constructor, or It is a lambda abstractionWHNF is not unique for an expression.Head Normal Form(HNF)An expression is in its head normal form if no further β-reduction can be done in the lambda body. HNF is automatically an WHNF.Normal Form(NF)Normal form is the most strict normal form. An expression is in its normal form if no further β-reduction and η-reduction can be done. NF is unique for any expression." }, { "title": "[LeetCode] 623. Add One Row to Tree", "url": "/posts/LeetCode-623.-Add-One-Row-to-Tree/", "categories": "Blogs", "tags": "leetcode", "date": "2020-07-31 18:33:10 +0900", "snippet": " Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N&#39;s left subtree root and right subtree root. And N&#39;s original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root’s left subtree. Example 1: Input: A binary tree as following: 4 / \\ 2 6 / \\ / 3 1 5 v = 1d = 2Output: 4 / \\ 1 1 / \\ 2 6 / \\ / 3 1 5 Example 2: Input: A binary tree as following: 4 / 2 / \\ 3 1 v = 1d = 3Output: 4 / 2 / \\ 1 1 / \\ 3 1 Note: The given d is in range [1, maximum depth of the given tree + 1]. The given binary tree has at least one tree node. SolutionThis is a insertion only with different rules. Here we need to consider three cases: If we arrive at the depth d we insert two nodes with value v as the left and right node of the current node. If the current node has a left subtree and a right subtree, then we perform a recursive call on its left subtree and right subtree If the current node only has a left subtree(or a right subtree) the we perform a recursive call on it left(right) subtree and leave the other side empty.data BTree = Node Int BTree BTree | EmptyTree deriving (Show, Eq, Read)addRow :: BTree -&amp;gt; Int -&amp;gt; Int -&amp;gt; BTreeaddRow (Node i left right) v d | (d - 1) == 1 = Node i (Node v left EmptyTree) (Node v EmptyTree right) | left /= EmptyTree &amp;amp;&amp;amp; right /= EmptyTree = Node i (addRow left v (d - 1)) (addRow right v (d-1)) | left /= EmptyTree = Node i (addRow left v (d - 1)) right | right /= EmptyTree = Node i left (addRow right v (d - 1))Complexity AnalysisThe worst time complexity and space complexity are both \\(O(n)\\) if we want to insert the value as the deepest row in the tree." }, { "title": "[LeetCode] 565. Array Nesting", "url": "/posts/LeetCode-565.-Array-Nesting/", "categories": "Blogs", "tags": "leetcode", "date": "2020-07-28 16:15:00 +0900", "snippet": " A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below. Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S. Example 1: Input: A = [5,4,0,3,1,6,2]Output: 4Explanation: A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.One of the longest S[K]:S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0} Note: N is an integer within the range [1, 20,000]. The elements of A are all distinct. Each element of A is an integer within the range [0, N-1]. SolutionThe most naïve method is to iterate over the whole list. For each element in the list, the walk function finds the length n of the path starting from start. It return the maximum length in the length list. It is intuitive but adds redundancy to the solution.arrayNesting :: [Int] -&amp;gt; IntarrayNesting arr = maximum $ map (\\x -&amp;gt; walk (arr !! x) x 0) arr where walk cur start n = if cur /= start then walk (arr !! cur) start (n + 1) else n + 1Consider a process with the list [1,2,3,4,0]: The path we take for all the elements in the list is actually identical and the list mapped with walk function is [5,5,5,5,5]. We can verify that each path is a closed loop so that no matter at which element we started to walk, the result will always be the period of the loop. We can utilize this property in a way that each time we encounter an element, mark it as visited. However, modifying a list in Haskell takes \\(O(n)\\) time as well as space. Clearly we need to use an array instead of a list to improve the current solution." }, { "title": "[LeetCode] 208. Implement Trie (Prefix Tree)", "url": "/posts/LeetCode-208.-Implement-Trie-(Prefix-Tree)/", "categories": "Blogs", "tags": "leetcode", "date": "2020-07-25 16:54:00 +0900", "snippet": " Implement a trie with insert, search, and startsWith methods. Example: Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // returns truetrie.search(&quot;app&quot;); // returns falsetrie.startsWith(&quot;app&quot;); // returns truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. SolutionA Trie Tree(Prefix Tree) is mainly used to retrieve a key from the dictionary. Things like Autocomplete in search engine and spell checker utilize this data structure extensively. A more detailed explanation can be found here.In a Trie Tree, each node has its links and a label indicating the end of a word. In my implementation, I used a map structure to store the links. Note that this implementation affects the performance of the operations on the Tree since the map is actually a linked-list of tuples instead of traditional arrays. Haskell do have array-like types (Data.Array, Data.Seq…), but here let’s focus more on the concept of a Trie Tree.data TrieNode = Node [(Char, TrieNode)] Bool deriving (Show, Read)root = Node [] Falsetip = Node [] Trueinsert :: String -&amp;gt; TrieNode -&amp;gt; TrieNodeinsert [] (Node links end) = tipinsert (a : str) (Node links end) | null $ fst match = Node ((a, insert str root) : links) end | otherwise = Node ((a, insert str $ snd . head . fst $ match) : snd match) end where match = partition (\\x -&amp;gt; a == fst x) linkssearch :: String -&amp;gt; TrieNode -&amp;gt; Boolsearch [] (Node _ end) = endsearch (a : str) (Node links _ ) = case lookup a links of Nothing -&amp;gt; False Just x -&amp;gt; search str xstartsWith :: String -&amp;gt; TrieNode -&amp;gt; BoolstartsWith [] _ = TruestartsWith (a : str) (Node links _) = case lookup a links of Nothing -&amp;gt; False Just x -&amp;gt; startsWith str xIn the insert function, basically what we do is to check the links of a node. If there is already a link for the character we would like to insert into, then we need to insert the rest of our string into the node that particular link points to. Since everything in Haskell is immutable, we must reconstruct a list of links for the node. On the other hand, if we are going to insert a character that is not presented in the links, we just prepend a new link to the list.Searching and finding prefix is pretty straightforward, we search the character in the links, if there is a hit then we proceed to the node it’s pointing to and search for the next one and so on. The difference is when checking a prefix, we don’t care if the node marks the end of a word.Complexity AnalysisFor insertion, the time complexity is \\(O(m)\\), where \\(m\\) is the length of the word. The space complexity is \\(O(m)\\).For searching, it is obvious that the time complexity is \\(O(m)\\) and the space complexity is \\(O(1)\\)." }, { "title": "[LeetCode] 955. Delete Columns to Make Sorted II", "url": "/posts/LeetCode-955.Delete-Columns-to-Make-Sorted-II/", "categories": "Blogs", "tags": "leetcode", "date": "2020-07-22 15:50:00 +0900", "snippet": " We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = [&quot;abcdef&quot;,&quot;uvwxyz&quot;] and deletion indices {0, 2, 3}, then the final array after deletions is [&quot;bef&quot;,&quot;vyz&quot;]. Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] &amp;lt;= A[1] &amp;lt;= A[2] ... &amp;lt;= A[A.length - 1]). Return the minimum possible value of D.length. Example 1: Input: [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]Output: 1Explanation:After deleting the first column, A = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].Now A is in lexicographic order (ie. A[0] &amp;lt;= A[1] &amp;lt;= A[2]).We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1. Example 2: Input: [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]Output: 0Explanation:A is already in lexicographic order, so we don&#39;t need to delete anything.Note that the rows of A are not necessarily in lexicographic order:ie. it is NOT necessarily true that (A[0][0] &amp;lt;= A[0][1] &amp;lt;= ...) Example 3: Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]Output: 3Explanation:We have to delete every column. SolutionLet’s solve it in a greedy approach. We can simply select the columns that make the array sorted.delCol :: [String] -&amp;gt; [String] -&amp;gt; [String]delCol arr tmp | null (head arr) = tmp | otherwise = delCol (map (drop 1) arr) $ if sorted trial then trial else tmp where sorted xs = and $ zipWith (&amp;lt;=) xs (tail xs) trial = zipWith (++) tmp $ map (take 1) arrsortByDelCol :: [String] -&amp;gt; IntsortByDelCol [] = 0sortByDelCol [x] = 0sortByDelCol arr = diffLen arr $ delCol arr [ &quot;&quot; | x &amp;lt;- arr ] where diffLen = (-) `on` (length . head)Here, tmp is used to store our selection of columns and trial is the next column to be selected. Since we want our list to be sorted in lexicographic order, we take the next columns if these columns are sorted, otherwise we just move on to the next iteration.Complexity AnalysisLet \\(m\\) be the number of elements in the array and \\(n\\) be the number of characters in each element.Making a trial takes \\(O(mn)\\) because both zipWith and map take linear time. Moreover, we are iterating over the length of the element \\(n\\) in the array. Thus, the overall time complexity is \\(O(mn^2)\\).The space complexity is simply \\(O(mn)\\)." } ]
